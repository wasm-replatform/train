# Copilot Instructions for Train Workspace

- **Mission Focus** Convert `legacy/at_smartrak_gtfs_adapter` (NestJS + at-realtime-common) into Rust. Lean on `crates/r9k-position` for idioms and follow Microsoft's Pragmatic Rust Guidelines (see microsoft.github.io/rust-guidelines/index.html). Target a WASM Component Model microservice: keep infrastructure in `src/lib.rs` and push domain logic into sibling crates for native testing.
- **Existing Rust Architecture** `src/lib.rs` exports `messaging::incoming_handler::Guest` and forwards messages to `credibil_api::Client`; build with `cargo build --package train --target wasm32-wasip2 --release` to produce `target/wasm32-wasip2/release/train.wasm` (mounted as `/r9k.wasm` in `compose.yaml`). `src/provider.rs` supplies the `Provider` trait; swap mocks for GTFS/Block/Fleet fetches once WIT HTTP bindings land. Study `crates/r9k-position/{handler.rs,r9k.rs,stops.rs}` for layering and validation patterns to mirror.
- **Legacy Adapter Highlights** `start.ts` and `container.ts` wire Kafka, Redis, KeyVault, and HTTP clients; replicate them as trait-based providers. `services/kafka-service.ts` routes by topic, enriches with `FleetApiService`, enforces tag gating, and publishes DR/VP outputsâ€”port this pipeline to Rust around your handler. `processors/location.ts` builds GTFS `VehiclePosition` or dead-reckoning outputs with per-vehicle locks, trip buffers, and occupancy lookups; `processors/serial-data.ts` and `processors/passenger-count.ts` maintain Redis caches with 3h/4h/24h TTLs and never crash on errors. Config modules expose env vars (`FLEET_API_URL`, `GOD_MODE`, thresholds); reflect them in Rust config structs for runtime loading.
- **Conversion Approach** Map Kafka topics from TS configs into `configure()` subscriptions and publish via `wit_bindings::messaging::producer::send`, keeping message keys aligned (`vpTopic`, `drTopic`). Replace `AsyncLock` with `tokio::sync::Mutex` or keyed task managers. Introduce cache/provider traits for Redis operations akin to `Provider::fetch` so tests can stub them. Translate NewRelic metrics into structured `tracing` counters (`info!(monotonic_counter.smartrak_skipped = 1, topic = %topic)`). Factor GodMode, passenger counts, occupancy math, and trip assignment into async modules with unit coverage using builders like `XmlBuilder` in `crates/r9k-position/tests/r9k.rs`.
- **Workflows & Quality Gates** Use `make build`, `make test`, `make fmt`, `make check`; `make test` runs `cargo nextest run --all --no-fail-fast --all-features` with `RUSTFLAGS=-Dwarnings`. Keep Clippy clean (`all`, `nursery`, `pedantic`, `cargo`, select restriction lints) and run `make check` before merging. After dependency bumps, follow `supply-chain/README.md` and `deny.toml` by running `cargo vet regenerate imports`, `exemptions`, and `unpublished`.
- **Testing Expectations** Add unit tests next to new crates under `crates/*/src` and `crates/*/tests`, covering Redis TTL rules, topic routing, occupancy edges, and error logging. Keep the WASM guest thin; integration coverage lives in pure Rust crates where native execution is available.
